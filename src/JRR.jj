/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(JRR)
import java.util.*;
class Quad{	Object op, arg1, arg2, result;
	public Quad(Object o, Object a1, Object a2, Object re)	{
	  op = o;
	  arg1 = a1;
	  arg2 = a2;
	  result = re;
	  //System.out.println(this);
	}
	
	@Override public String toString()
	{
		String s = ">";
		if (op != null) s = s+op.toString()+"<	>";
	  	else s = s+"NULL"+"<	>";
  		if (arg1 != null) s = s+arg1.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (arg2 != null) s = s+arg2.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (result != null) s = s+result.toString();
		else s = s+"NULL";
		return s;
	}
}

public class JRR
{
  public static ArrayList<String> symbol_table;
  public static ArrayList<Quad> quad_list;
  public static Stack<Object> semantic_stack;
  public static Stack<Integer> pointer_stack;
  public static void main(String args []) throws ParseException
  {
    JRR parser = new JRR(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      try
      {
        JRR.semantic_stack = new Stack<Object>();
        JRR.pointer_stack = new Stack<Integer>();
        JRR.quad_list = new ArrayList<Quad>();
        JRR.symbol_table = new ArrayList<String>();
        JRR.program();
        System.out.println("Successful Parsing.");
        System.out.println("\n------------------Symbol Table------------------");
		for (String symb: symbol_table)
			System.out.println("Symbol :"+symb);
		System.out.println("\n------------------Stack------------------");
		System.out.println("Semantic Stack: "+semantic_stack);
		System.out.println("Pointer Stack: "+semantic_stack);
		//while (!semantic_stack.empty())
		//	System.out.println("Stack Item :"+semantic_stack.pop().toString());
		System.out.println("\n------------------Quads------------------");
		for (int i=0; i<quad_list.size();i++)
			System.out.println("Quad :"+i+"	"+quad_list.get(i));
           
      }
      catch(ParseException e){
        System.err.println("Fail Parsing");
        System.err.println(e);
        e.printStackTrace();
        break;
      }
      catch (Exception e)
      {
        System.out.println("NOK. Other Exception. ");
        e.printStackTrace();
        JRR.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops. Error.");
        System.out.println(e.getMessage());
        break;
      }
      
    }
  }
}

PARSER_END(JRR)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : /* OPERATORS */
{
//  < ADDOP : ["+","-"] >
//| < UNARYOP : ["-","!"] >
//| < MULOP : ["*","/","%"] >
//| < RELOP : < LESSERTHAN >|< GRATERTHAN > >
//|
< LBRACE : "{" >
| < RBRACE : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LESSERTHAN : "<" >
| < GRATERTHAN : ">" >
}



TOKEN : // Reserved Words
{
  < BREAK:  "break" >
| < CONTINUE:  "continue" >
| < ELSE:  "else" >
| < IF:  "if" >
| < RETURN:  "return" >
| < WHILE:  "while" >
}

TOKEN : // ID and Digits
{
  < ID:  < LETTER >(< LETTER >|< DIGIT >)* >
| < #LETTER: ["a"-"z","A"-"Z","_"]>
| < INT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}


void program():{}
{
	{ System.out.println("program1");}
	< LBRACE > (statement())* < RBRACE > <EOF>
}

void compound():{}
{
	{ System.out.println("compound1");}
	< LBRACE > (statement())* < RBRACE > 
}

void statement():{Object a, b, c;}
{
	//========== COMPOUND ===========
	compound() {
		System.out.println("Stack sta: "+semantic_stack+"1\n");
	}
	|
	
	//========== WHILE CLAUSE ===========
	< WHILE >	{
		pointer_stack.push(quad_list.size());	}
	test()  {
		a = semantic_stack.pop();
		pointer_stack.push(quad_list.size());
		quad_list.add(new Quad("jeqz",a,null,-1));	}
	statement() {
		a = pointer_stack.pop();
		b = pointer_stack.pop();
		quad_list.add(new Quad("jmp",null,null,b));
		quad_list.get((int)a).result = quad_list.size();
		System.out.println("Stack sta: "+semantic_stack+"2\n");
	}
	|

	//========== IF CLAUSE ===========
	< IF > test()	{
		a = quad_list.size();
		b = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",b,null,-1));
		pointer_stack.push((int)a); 	} statement() (LOOKAHEAD(2) < ELSE >   {
		a = quad_list.size(); //quad_list.size() MEANS NextQuad
		quad_list.add(new Quad("jmp",null,null,-1));
		b = pointer_stack.pop();
		quad_list.get((int)b).result = quad_list.size();
		pointer_stack.push((int)a);     	} statement())? {
		a = pointer_stack.pop();
		quad_list.get((int)a).result = quad_list.size();
		System.out.println("Stack sta: "+semantic_stack+"3\n");
	}
	|

	//========== EXPRESSION ===========
	expression() ";" {
		semantic_stack.pop();
		System.out.println("Stack sta: "+semantic_stack+"4\n");
	}
	|

	//========== BREAK CLAUSE ===========
	< BREAK >";" { //TODO implement BREAK
		a = pointer_stack.pop();
		b = quad_list.size();
		quad_list.add(new Quad("jmp",null,null,a));
		quad_list.get((int)a).result = b;
		pointer_stack.push((int)b);
		System.out.println("Stack sta: "+semantic_stack+"5\n");
	}
	|

	//========== RETURN CLAUSE ===========
	< RETURN > expression()";" {
		a = semantic_stack.pop();
		quad_list.add(new Quad("ret",null,null,a));
		System.out.println("Stack sta: "+semantic_stack+"6\n");
	}
	|
	
	//========== CONTINUE CLAUSE ===========
	< CONTINUE > ";" {
		a = pointer_stack.peek();
		quad_list.add(new Quad("jmp",null,null,a));
		System.out.println("Stack sta: "+semantic_stack+"7\n");
	}
	|

	//========== SEMICOLON ===========
	";" {
		System.out.println("Stack sta: "+semantic_stack+"8\n");
	}
}

void test():{}
{
	{ System.out.println("test");}
	< LPAREN > expression() < RPAREN > 
}

void expression():{} 
{
	LOOKAHEAD(2)  
	{ Token id; }
	id=< ID >	{
	  semantic_stack.push(id.image);
	}
	"=" expression() {
		Object a = semantic_stack.pop(); //the latter
		Object b = semantic_stack.pop(); //the first (destination)
		quad_list.add(new Quad("mov",a,null,b));
		semantic_stack.push(a);
	}
	|
	condition() 
}

void condition():{Object a, b, c;}
{
	disjunction() ("?"	{
		a = quad_list.size();
		b = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",b,null,-1));
		pointer_stack.push((int)a);
		Object dest = semantic_stack.pop(); // the place to be assigned
	}
	expression() ":"	{
		c = semantic_stack.peek();
		quad_list.add(new Quad("mov",c,null,dest));
		a = quad_list.size(); 
		quad_list.add(new Quad("jmp",null,null,-1));
		b = pointer_stack.pop();
		quad_list.get((int)b).result = quad_list.size();
		pointer_stack.push((int)a);
	}
	condition() 	{
		c = semantic_stack.pop();
		quad_list.add(new Quad("mov",c,null,dest));
		a = pointer_stack.pop();
		quad_list.get((int)a).result = quad_list.size();  
		semantic_stack.push(dest);
	}
	)?
}

void disjunction():{}
{
	conjunction() ("|" conjunction()	{
		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("or",c,b,a));
		semantic_stack.push(a);
	}
	)*  
}

void conjunction():{}
{
	comparison() ("&" comparison()	{
		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("and",c,b,a));
		semantic_stack.push(a);	}
	)*
}

void comparison():{}
{
	relation() ("==" relation() {
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("tst",c,b,a));
		semantic_stack.push(a);
	}
	)? 
}

void relation():{String op;}
{
	sum() (op=relop() sum()	{
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)?
}

void sum():{String op;}
{
	term()( op=addop() term()	{
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);	}
	)*
}

void term():{String op;}
{
	factor() (op=mulop() factor() {		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)*
}

void factor():{}
{
	primary()
	|
	unaryop() primary() {		Object a = new Object();
		Object b = semantic_stack.pop();
		quad_list.add(new Quad("neg",b,null,a));
		semantic_stack.push(a);
		//System.out.println("Stack fac: "+semantic_stack);
	}
}

void primary():{}
{  
	{ Token id; }
	id = < ID >  {
	if (!symbol_table.contains(id.image))
		symbol_table.add(id.image);
    semantic_stack.push(id.image);
    }
    |
    {Token i;}
    i = < INT >	{		semantic_stack.push(Integer.parseInt(i.image));
	}
	|
	< LPAREN > expression() < RPAREN > 
}

String relop():{}
{
	< LESSERTHAN >{return "LT";}
	|
	< GRATERTHAN >{return "GT";}
}

String mulop():{}
{
	"*"  {return "*";}
	|
	"/"  {return "/";}
	|
	"%"  {return "%";}
}

String addop():{}
{
	"-"{return "-";}
	|
	"+"{return "+";}
}

String unaryop():{}
{
	"-"{return "-";}
	|
	"!"{return "!";}
}

// E: E+T|T  becomes E: T(+T)*
