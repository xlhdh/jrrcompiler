/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(JRR)
import java.util.*;

class Symbol
{
	public String name;
	public int nextuse, regloc, memloc;
	//public String value; //for immediate values only
	public String type; // "int", "id", "temp"
	
	public Symbol(String s, String t) // for named symbol 
	{	// immediate values are treated as permanent in case of next use. 
		name = s;
		nextuse= 0;
		regloc = -1;
		memloc = -1;
		type = t;
	}

	public Symbol() // for temp symbol
	{	
		name = null;
		nextuse= -1;
		regloc = -1;
		memloc = -1;
		type = "temp";	
	}

	public boolean alive()	{
		return (nextuse >-1);	}

	public void ini()
	{
		if (type.equals("id"))
			nextuse = 0;
		else
			nextuse = -1; 	}

	public void store(Memory m, ArrayList<String> inst_list)
	{
	  
		if ((nextuse > -1) && (regloc > -1) && (memloc==-1)) // if in reg, not in mem, has next use		{
			memloc = m.avail();
			inst_list.add("MOVL\t%R"+regloc+",\t0x"+Integer.toHexString(memloc)+"\n");
		}	}

	@Override public boolean equals(Object o)
	{
		//System.out.println(o.getClass().getName());
		if (o instanceof Symbol)
			return (name.equals(((Symbol)o).name));
		else return false;
	}
	
	@Override public String toString()
	{
		//return "Symbol(["+name+"]["+nextuse+"])";
		if (regloc > -1) return 	"%R"+regloc;
		else if (type.equals("int")) return "$"+name;		
		else if (memloc > -1) return 	"0x"+Integer.toHexString(memloc);
		else return null; // This is error. Code should never reach here - "FROM" unassigned named variable 
	}
}
class RegManager
{
	ArrayList<ArrayList<Integer>> regs;
	Memory m;
	ArrayList<Symbol> st;
	ArrayList<String> inst_list;
	
	public RegManager(int cap, Memory m1, ArrayList<Symbol> st1, ArrayList<String> il)
	{
		regs = new ArrayList<ArrayList<Integer>>();
		for (int i = 0; i < cap; i++) regs.add(new ArrayList<Integer>());
		m = m1;
		st = st1;
		inst_list = il; 
	}

	boolean regavail (ArrayList<Integer> reg)
	{
		//System.out.println("in regavail, "+reg);
		for (Integer i: reg)
			if (st.get(i).alive()) return false;			
		return true;
	}

	public int findreg ()
	{
		for (int i = 0; i < regs.size(); i++)
		{
			if (regavail(regs.get(i)))
				return i;
		}
		// fail to find a empty reg
		int r = 0;
		for (int i = 0; i < regs.get(r).size(); i++)
		{
			st.get(regs.get(r).get(i)).store(m, inst_list);
		}
		regs.set(r, new ArrayList<Integer>());		
		return r;
	}
	
}

class Memory
{
	ArrayList<Boolean> m;
	int base, step;
	public Memory(int cap)
	{
		m = new ArrayList<Boolean>(cap);
		for (int i = 0; i < 256; i++) m.add(false);
		base = 0; //eax: 32bits, 4bytes
		step = 4;
	}
	int avail()	{
		int i = m.indexOf(false);
		m.set(i, true);
		return i;	}

}

class Quad{	String op;
	int arg1, arg2, result;
	int arg1next, arg2next, renext;
	boolean leader;
	int address;
	public Quad(String o, int a1, int a2, int re)	{
	  op = o;
	  arg1 = a1;	  
	  arg2 = a2;
	  result = re;
	  
	  leader = false;
	  arg1next = -1;
	  arg2next = -1;
	  renext = -1;
	  address = -1;
	}
	
	@Override public String toString()
	{
		String s = ">";
		/*if (op != null) s = s+op.toString()+"<	>";
	  	else s = s+"NULL"+"<	>";
  		if (arg1 != null) s = s+arg1.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (arg2 != null) s = s+arg2.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (result != null) s = s+result.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		s = s+leader+"<";*/
		s = s + op + "<	>";
		s = s + arg1+","+arg1next + "<	>";
		s = s + arg2+","+arg2next + "<	>";
		s = s + result+","+renext + "<\t" + leader;
		
		return s;
		
	}
}


public class JRR
{
  
	public static ArrayList<Symbol> symbol_table;
	public static ArrayList<Quad> quad_list;
	public static ArrayList<String> inst_list;
	public static Stack<Integer> semantic_stack;
	public static Stack<Integer> cdtn_stack, loop_stack;
	//public static String ins;
	public static RegManager rm;
	public static Memory memory;
  
  public static void main(String args []) throws ParseException
  {
    JRR parser = new JRR(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      try
      {
        JRR.symbol_table = new ArrayList<Symbol>();
        
        JRR.semantic_stack = new Stack<Integer>();
        
        JRR.cdtn_stack = new Stack<Integer>();
        JRR.loop_stack = new Stack<Integer>();
        
        JRR.quad_list = new ArrayList<Quad>();
        JRR.inst_list = new ArrayList<String>();
        
        JRR.memory = new Memory(256);
        JRR.rm = new RegManager(8, memory, symbol_table, inst_list);
        JRR.program();
        //JRR.ins = "";
        System.out.println("Successful Parsing.");
        System.out.println("\n------------------Stack------------------");
		System.out.println("Semantic Stack: "+semantic_stack);
		System.out.println("Cdtn Stack: "+cdtn_stack);
		System.out.println("Loop Stack: "+loop_stack);
		cleanJumps(quad_list);
		findLeaders(quad_list);
		
		System.out.println("\n------------------Symbol Table------------------");
		for (int i=0; i<symbol_table.size();i++)
			System.out.println("Symbol :"+i+"	"+symbol_table.get(i).name);
			
		genCode(quad_list);

		System.out.println("\n------------------Quads------------------");
		for (int i=0; i<quad_list.size();i++)
			System.out.println("Quad :"+i+"	"+quad_list.get(i));

		addJumpDest(inst_list, quad_list);

		System.out.println("\n------------------Instructions------------------");
		for (int i=0; i<inst_list.size();i++)
			System.out.print("Addr: 0x"+Integer.toHexString(i*2)+"	"+inst_list.get(i));

		
        
      }
      catch(ParseException e){
        System.err.println("Fail Parsing");
        System.err.println(e);
        e.printStackTrace();
        break;
      }
      catch (Exception e)
      {
        System.out.println("Exception. ");
        e.printStackTrace();
        JRR.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Error.");
        System.out.println(e.getMessage());
        break;
      }
      
    }
}
	public static void cleanJumps(ArrayList<Quad> list) // consolidate linked jumps in quads
	{    
		for (int i = 0; i<list.size(); i++)	{
		  
			if (list.get(i).op.startsWith("j"))	{
				int crt = list.get(i).result;
				while (list.get(crt).op.equals("jmp"))
					crt = list.get(crt).result;
				list.get(i).result = crt;
			}
			
		}
	}

	public static void findLeaders(ArrayList<Quad> list)	{
		list.get(0).leader=true;		for (int i = 1; i<list.size()-1; i++)		{
			if (list.get(i).op.startsWith("j") )
			{				list.get(list.get(i).result).leader = true;
				if (!list.get(i).op.equals("jump"))
					list.get(i+1).leader = true;
			}		}
		// Last Quad: "exit" is not iterated over. always false unless set to be true
	}	

	public static void addJumpDest(ArrayList<String> slist, ArrayList<Quad> qlist)
	{
		for (int i = 1; i<slist.size()-1; i++)
		{
			if ( !slist.get(i).startsWith("X") )
				continue;
			int addr = qlist.get(Integer.parseInt(slist.get(i).substring(5))).address; 
			if (slist.get(i).startsWith("XJZZ") )
				slist.set(i, "JZ\t0x"+Integer.toHexString(addr)+"\n");
			else if (slist.get(i).startsWith("XJMP") )
				slist.set(i, "JMP\t0x"+Integer.toHexString(addr)+"\n");
		}	}

	public static void quad2code(int i)	{
		quad_list.get(i).address = inst_list.size();
		int reg=-1;
		String opr = "";
		int b = quad_list.get(i).arg1;
		int bn = quad_list.get(i).arg1next;
		int c = quad_list.get(i).arg2;
		int cn = quad_list.get(i).arg2next;
		int a = quad_list.get(i).result;
		int an = quad_list.get(i).renext;
		System.out.println("Quad "+i);
		switch (quad_list.get(i).op)	{		
			// ASSIGNMENT
			case "mov":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				// if B is not in a reg
				if (symbol_table.get(b).regloc < 0) 				{
					reg = rm.findreg();
					inst_list.add("MOVL\t"+symbol_table.get(b)+",\t%R"+reg+"\n");
					rm.regs.get(reg).add(b);
					symbol_table.get(b).regloc = reg;
				}
				else reg = symbol_table.get(b).regloc;

				
				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
				  
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;				}

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}

				rm.regs.get(reg).add(a);
				
				break;
				
			// ARITHMETIC/LOGICAL
			case "+":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "ADDL";

				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%R"+reg+",\t"+"%R"+reg+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				
				
				break;
				
			case "-":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "SUBL";

				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%R"+reg+",\t"+"%R"+reg+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				
				break;
				
			case "*":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "IMUL";
				
				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%EAX"+"\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%EAX"+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+"\n");
				
				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				inst_list.add("MOVL"+"\t"+"%EAX"+",\t"+"%R"+reg+"\n");

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				
				break;
				
			case "/":				
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "IDIV";
				
				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%EAX"+"\n");

				inst_list.add("CDQ\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%EAX"+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+"\n");
				
				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				inst_list.add("MOVL"+"\t"+"%EAX"+",\t"+"%R"+reg+"\n");

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				
				break;
				
			case "%":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "IDIV";
				
				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%EAX"+"\n");

				inst_list.add("CDQ\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%EAX"+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+"\n");
				
				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				inst_list.add("MOVL"+"\t"+"%EDX"+",\t"+"%R"+reg+"\n");

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				
				break;
				
			case "&":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "ANDL";

				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%R"+reg+",\t"+"%R"+reg+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				
				break;
				
			case "|":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "ORL";

				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				if (b==c)
					inst_list.add(opr+"\t"+"%R"+reg+",\t"+"%R"+reg+"\n");
				else 
					inst_list.add(opr+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
							
				break;
				
			case "NOT":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "NOTL";
				
				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				inst_list.add(opr+"\t"+"%R"+reg+"\n");

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				break;
				
			case "NEG":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "NEGL";
				
				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				inst_list.add(opr+"\t"+"%R"+reg+"\n");

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				break;
				
			// RELATIONAL
			case "GT":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "CMP";

				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				inst_list.add(opr+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");

				// CMP A, B
				// JG jumps if b is greater				
				inst_list.add("JG\t"+".+"+4+"\n"); // Jump to P1 					// 7F XX
				inst_list.add("MOVL\t$0x"+0+",\t"+"%R"+reg+"\n");	    // MV 00 RR
				inst_list.add("JMP\t"+".+"+2+"\n"); //Jump to P2					// JP XX
				// P1
				inst_list.add("MOVL\t$0x"+1+",\t"+"%R"+reg+"\n");	    // MV 00 RR
				// P2				

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);

				break;
				
			case "LT":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				opr = "CMP";

				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				inst_list.add(opr+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");

				// CMP A, B
				// JG jumps if b is greater				
				inst_list.add("JL\t"+".+"+4+"\n"); // Jump to P1 					// 7F XX
				inst_list.add("MOVL\t$0x"+0+",\t"+"%R"+reg+"\n");	    // MV 00 RR
				inst_list.add("JMP\t"+".+"+2+"\n"); //Jump to P2					// JP XX
				// P1
				inst_list.add("MOVL\t$0x"+1+",\t"+"%R"+reg+"\n");	    // MV 00 RR
				// P2				

				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}

				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				break;
				
			case "cpr":
				symbol_table.get(b).nextuse = bn;
				symbol_table.get(a).nextuse = an;
				reg = rm.findreg();
				
				inst_list.add("MOVL"+"\t"+symbol_table.get(b)+",\t"+"%R"+reg+"\n");

				if (b==c)
					inst_list.add("SUBL"+"\t"+"%R"+reg+",\t"+"%R"+reg+"\n");
				else 
					inst_list.add("SUBL"+"\t"+symbol_table.get(c)+",\t"+"%R"+reg+"\n");
					
				// if B is not live and is in a reg
				if (bn<0 && (symbol_table.get(b).regloc > -1)) {
					rm.regs.get(symbol_table.get(b).regloc).remove((Integer)b);
					symbol_table.get(b).regloc = -1;
				}
				// if C is not live and is in a reg
				if (cn<0 && (symbol_table.get(c).regloc > -1)) {
					rm.regs.get(symbol_table.get(c).regloc).remove((Integer)c);
					symbol_table.get(c).regloc = -1;
				}
				symbol_table.get(c).nextuse = cn;
				

				// CMP A, B
				// JZ jumps if zero. MOV changes flags
				inst_list.add("JZ\t"+".+"+4+"\n"); // Jump to P1 					// 7F XX
				inst_list.add("MOVL\t$0x"+0+",\t"+"%R"+reg+"\n");	    // MV 00 RR
				inst_list.add("JMP\t"+".+"+2+"\n"); //Jump to P2					// JP XX
				// P1
				inst_list.add("MOVL\t$0x"+1+",\t"+"%R"+reg+"\n");	    // MV 00 RR
				// P2				

				// update A: only in REG
				symbol_table.get(a).regloc = reg;
				if (symbol_table.get(a).memloc > -1)
				{				  
					memory.m.set(symbol_table.get(a).memloc, false);
					symbol_table.get(a).memloc = -1;
				}
				rm.regs.get(reg).add(a);
				break;
										
			// JUMPS 
			case "jmp":
				for (Symbol sb: symbol_table)
				{
					sb.store(memory, inst_list);
					sb.regloc = -1;						
				}

				rm = new RegManager(8, memory, symbol_table, inst_list);

				inst_list.add("XJMP\t"+a); // pass the quad number to it, not the instruction number.
				//System.out.println("XJMP\t"+a+"\n");
				break;
				
			case "jeqz":
				reg = rm.findreg();
			
				inst_list.add("MOVL\t"+symbol_table.get(b)+",\t%R"+reg+"\n");
				
				for (Symbol sb: symbol_table)
				{				  
					sb.store(memory, inst_list);
					sb.regloc = -1;		
				}

				inst_list.add("MOVL\t"+"%R"+reg+",\t"+"%EAX"+"\n");
				inst_list.add("XJZZ\t"+a); // should be JZ
				//System.out.println("XJZZ\t"+a+"\n");

				rm = new RegManager(8, memory, symbol_table, inst_list);	// does not produce insts
				
				break;
				
			case "ret":
				reg = rm.findreg();
			
				inst_list.add("MOVL\t"+symbol_table.get(b)+",\t%R"+reg+"\n");
				
				for (Symbol sb: symbol_table)
				{				  
					sb.store(memory, inst_list);
					sb.regloc = -1;		
				}
				rm = new RegManager(8, memory, symbol_table, inst_list);

				// Simply move changes the flags
				inst_list.add("MOVL"+"\t"+"%R"+reg+",\t"+"%EAX"+"\n");

				inst_list.add("RET\n"); 
				//System.out.println("RET\n");
				break;
				
			case "exit":
				inst_list.add("INT 9\n");
				break;
				
			default: //IRET
				System.err.println("Invalid op: "+quad_list.get(i).op);
				break;
		}
	}

	public static void genCode(ArrayList<Quad> list)	{
		int crt = 0;		
		int next = crt+1;
		while (next<list.size())		{			// ----- PREPARE ELIMINATORS FOR CURRENT BLOCK ----- //
			while ( (!list.get(next).leader) && (next<list.size()) ) next++;
			// crt, next are leaders of current and next basic blocks

			// ----- PERFORM LIVE VARIABLE ANALYSIS ----- //

			// -------- Initialize Symbol Table -------- //
			for (Symbol s: symbol_table) s.ini();

			// -------- Scan Block Backwards -------- //
			for (int i = next-1; i >= crt; i--)			{
				Quad q = list.get(i);
				//System.out.println(q);
				if (q.op.startsWith("j") || q.op.startsWith("ret"))
					continue; 
				
				// Symbol Table - > Quads				
				q.arg1next = symbol_table.get(q.arg1).nextuse;
				if (q.arg2 >-1)
					q.arg2next = symbol_table.get(q.arg2).nextuse;
				q.renext = symbol_table.get(q.result).nextuse;

				// Set new values for Symbol Table
				symbol_table.get(q.result).nextuse = -1;
				if (q.arg2 >-1)
					symbol_table.get(q.arg2).nextuse = i;
				symbol_table.get(q.arg1).nextuse = i;

				//System.out.println("\t"+q);			}
			
			// ----- GENERATE CODE ----- //
			for (int i = crt; i < next; i++)				quad2code(i);

			// ----- GENERATE STORAGE INSTUCTIONS ----- //
			for (Symbol s: symbol_table) s.store(memory, inst_list); // Leave in Registers
			/*for (Symbol sb: symbol_table)
				{
					sb.store(memory);
					sb.regloc = -1;						
				}*/

			rm = new RegManager(8, memory, symbol_table, inst_list);

			// END OF THIS BLOCK //
			System.out.println("This block is: "+crt+"\t"+next);
			crt = next;
			next++; // when crt is exit, next is oob
		}
		quad2code(next-1);	}
}

PARSER_END(JRR)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> //comments 
}

TOKEN : /* OPERATORS */
{
< LBRACE : "{" >
| < RBRACE : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LESSERTHAN : "<" >
| < GRATERTHAN : ">" >
}

TOKEN : // Reserved Words
{
  < BREAK:  "break" >
| < CONTINUE:  "continue" >
| < ELSE:  "else" >
| < IF:  "if" >
| < RETURN:  "return" >
| < WHILE:  "while" >
}

TOKEN : // ID and Digits
{
  < ID:  < LETTER >(< LETTER >|< DIGIT >)* >
| < #LETTER: ["a"-"z","A"-"Z","_"]>
| < INT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}


void program():{}
{
	< LBRACE > (statement())* < RBRACE > <EOF>	{
		quad_list.add(new Quad("exit",-10,-10,-10));	}	
}

void compound():{}
{
	< LBRACE > (statement())* < RBRACE > 
}

void statement():{int a; int t1, t2; }
{
	//========== COMPOUND ===========
	compound() {}
	|
	
	//========== WHILE CLAUSE ===========
	< WHILE >	{
		loop_stack.push(quad_list.size());	}
	test()  {
		a = semantic_stack.pop();
		loop_stack.push(quad_list.size());
		quad_list.add(new Quad("jeqz",a,-10,-1));	}
	statement() {
		t1 = loop_stack.pop(); // where loop body(conditional jump) starts
		t2 = loop_stack.pop(); // where loop testing block starts 
		quad_list.add(new Quad("jmp",-10,-10,t2));
		quad_list.get(t1).result = quad_list.size();
	}
	|

	//========== IF CLAUSE ===========
	< IF > test()	{
		t1 = quad_list.size(); //quad_list.size() MEANS NextQuad
		a = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",a,-10,-1));
		cdtn_stack.push(t1); 	} statement() (LOOKAHEAD(2) < ELSE >   {
		t1 = quad_list.size(); 
		quad_list.add(new Quad("jmp",-10,-10,-1));
		t2 = cdtn_stack.pop();
		quad_list.get(t2).result = quad_list.size();
		cdtn_stack.push(t1);     	} statement())? {
		t1 = cdtn_stack.pop();
		quad_list.get(t1).result = quad_list.size();
	}
	|

	//========== EXPRESSION ===========
	expression() ";" {
		semantic_stack.pop();
	}
	|

	//========== BREAK CLAUSE ===========
	< BREAK >";" { //TODO implement BREAK
		t1 = loop_stack.pop();
		t2 = quad_list.size();
		quad_list.add(new Quad("jmp",-10,-10,t1));
		quad_list.get(t1).result = t2;
		loop_stack.push(t2);
	}
	|

	//========== RETURN CLAUSE ===========
	< RETURN > expression()";" {
		a = semantic_stack.pop();
		quad_list.add(new Quad("ret",a,-10,-10));
	}
	|
	
	//========== CONTINUE CLAUSE ===========
	< CONTINUE > ";" {
		t2 = loop_stack.pop();
		t1 = loop_stack.peek(); // the starting point of test is one into the top of stack
		loop_stack.push(t2);
		quad_list.add(new Quad("jmp",-10,-10,t1));
	}
	|

	//========== SEMICOLON ===========
	";" {
	}
}
void test():{}
{
	< LPAREN > expression() < RPAREN > 
}

void expression():{} 
{
	LOOKAHEAD(2)  
	{ Token id; }
	id=< ID >	{
		Symbol s = new Symbol(id.image, "id");
		int i = symbol_table.indexOf(s);
		if (i<0) symbol_table.add(s);
		i = symbol_table.indexOf(s);
		semantic_stack.push(i);
	}
	"=" expression() {
		int a = semantic_stack.pop(); //the latter
		int b = semantic_stack.pop(); //the first (destination)
		quad_list.add(new Quad("mov",a,-10,b));
		semantic_stack.push(b);
	}
	|
	condition() 
}

void condition():{int a, b, c; int t1, t2;}
{
	disjunction() ("?"	{
		t1 = quad_list.size();
		a = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",a,-10,-1));
		cdtn_stack.push(t1);
		int dest = symbol_table.size();
		symbol_table.add(new Symbol()); // the place to be assigned
	}
	expression() ":"	{
		b = semantic_stack.pop();
		quad_list.add(new Quad("mov",b,-10,dest));
		t1 = quad_list.size(); 
		quad_list.add(new Quad("jmp",-10,-10,-1));
		t2 = cdtn_stack.pop();
		quad_list.get(t2).result = quad_list.size();
		cdtn_stack.push(t1);
	}
	condition() 	{
		c = semantic_stack.pop();
		quad_list.add(new Quad("mov",c,-10,dest));
		t1 = cdtn_stack.pop();
		quad_list.get(t1).result = quad_list.size();  
		semantic_stack.push(dest);
	}
	)?
}

void disjunction():{int a, b, c;}
{
	conjunction() ("|" conjunction()	{
		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		c = semantic_stack.pop();
		quad_list.add(new Quad("|",c,b,a));
		semantic_stack.push(a);
	}
	)*  
}

void conjunction():{int a, b, c;}
{
	comparison() ("&" comparison()	{
		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		c = semantic_stack.pop();
		quad_list.add(new Quad("&",c,b,a));
		semantic_stack.push(a);	}
	)*
}

void comparison():{int a, b, c;}
{
	relation() ("==" relation() {
  		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		c = semantic_stack.pop();
		quad_list.add(new Quad("cpr",c,b,a));
		semantic_stack.push(a);
	}
	)? 
}

void relation():{int a, b, c;String op;}
{
	sum() (op=relop() sum()	{
  		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)?
}

void sum():{int a, b, c;String op;}
{
	term()( op=addop() term()	{
  		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);	}
	)*
}

void term():{int a, b, c;String op;}
{
	factor() (op=mulop() factor() {		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)*
}

void factor():{}
{
	primary()
	|
	{int a, b; String op;}
	op=unaryop() primary() {		a = symbol_table.size();
		symbol_table.add(new Symbol());
		b = semantic_stack.pop();
		quad_list.add(new Quad(op,b,-10,a));
		semantic_stack.push(a);
	}
}

void primary():{int a; Symbol s;}
{  
	{ Token id; }
	id = < ID >  {
		s = new Symbol(id.image, "id");
		a = symbol_table.indexOf(s);
		if (a<0)		{			symbol_table.add(s);
			System.err.println("Reference before assignment: "+id.image);
		}
		a = symbol_table.indexOf(s);
		semantic_stack.push(a);
    }
    |
    {Token i;}
    i = < INT >	{		//semantic_stack.push(Integer.parseInt(i.image));
		s = new Symbol(i.image, "int");
		a = symbol_table.indexOf(s);
		if (a<0) symbol_table.add(s);
		a = symbol_table.indexOf(s);
		semantic_stack.push(a);
	}
	|
	< LPAREN > expression() < RPAREN > 
}

String relop():{}
{
	< LESSERTHAN >{return "LT";}
	|
	< GRATERTHAN >{return "GT";}
}

String mulop():{}
{
	"*"  {return "*";}
	|
	"/"  {return "/";}
	|
	"%"  {return "%";}
}

String addop():{}
{
	"-"{return "-";}
	|
	"+"{return "+";}
}

String unaryop():{}
{
	"-"{return "NEG";}
	|
	"!"{return "NOT";}
}

// E: E+T|T  becomes E: T(+T)*
