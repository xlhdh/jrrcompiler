/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(JRR)
import java.util.*;

class Symbol
{
	public Object name;
	public int nextuse;
	public Symbol(Object o)
	{	
		name = o;
		nextuse = -1;
	}
	public Symbol(Object o, int n)
	{	
		name = o;
		nextuse = n;
	}

	@Override public boolean equals(Object o)
	{
		return (((Symbol)o).name.equals(name));
	}
	@Override public String toString()
	{
		return "(["+name+"]["+nextuse+"])";		
	}
}

class Quad{	String op;
	Object arg1, arg2, result;
	boolean leader;
	public Quad(String o, Object a1, Object a2, Object re)	{
	  op = o;

	  //System.out.println(a1 + "" + (arg1 instanceof Integer));
	  
	  if ((a1 instanceof Integer)||a1==null)	arg1 = a1;
	  else arg1 = new Symbol(a1);
	  
	  if ((a2 instanceof Integer)||a2==null)	arg2 = a2;
	  else arg2 = new Symbol(a2);
	  
	  if ((re instanceof Integer)||re==null)	result = re;
	  else result = new Symbol(re);
	  
	  leader = false;
	  //System.out.println(this);
	}
	
	@Override public String toString()
	{
		String s = ">";
		if (op != null) s = s+op.toString()+"<	>";
	  	else s = s+"NULL"+"<	>";
  		if (arg1 != null) s = s+arg1.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (arg2 != null) s = s+arg2.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (result != null) s = s+result.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		s = s+leader+"<";
		return s;
	}
}



class SymbolTable
{
	class RegManager
	{
		List<List<Object>> regs;
		public RegManager()
		{
			regs = new ArrayList<List<Object>>(16);
		}
	
		boolean regavail (List<Object> l)
		{
			for (Object o: l)
				if (alive(o)) return false;
			return true;
		}
	
		public int findreg ()
		{
			for (int i = 0; i < regs.size(); i++)
			{
				if (regavail(regs.get(i)))
					return i;
			}
			// fail to find a empty reg
			int i = 0;
			for (Object o: regs.get(i))
			{
				//TODO generate store inst. for all those names in that reg
				//TODO update st locations for those names
				System.out.println("store"+o);
			}			
			return i;
		}
	}
	
	ArrayList<Object> name;
	ArrayList<Integer> nextuse;
	ArrayList<Integer> regloc;
	ArrayList<Integer> memloc;
	RegManager rm; 

	public SymbolTable ()	{
		name = new ArrayList<Object>();
		nextuse = new ArrayList<Integer>();
		regloc = new ArrayList<Integer>();
		memloc = new ArrayList<Integer>();
		rm = new RegManager();	}

	public boolean add(Object o)
	{
		if (!name.contains(o))
		{
			name.add(o);
			nextuse.add(-1);
			regloc.add(null);
			memloc.add(null);
			return true;
		}
		else return false;
	}
	
	public void add(Object o, int n)
	{
		if (!name.contains(o))
		{
			name.add(o);
			nextuse.add(n);
			regloc.add(null);
			memloc.add(null);
		}
		else setnext(o,n);
	}
	
	public boolean del(Object o)
	{
		if (name.contains(o))
		{
			int i = name.indexOf(o);
			name.remove(i);
			nextuse.remove(i);
			regloc.remove(i);
			memloc.remove(i);
			return true;
		}
		else return false;
	}

	public void housekeeping()	{
		for (int i = 0; i<name.size(); i++)
		{
			if (!(name.get(i) instanceof String))
				del(name.get(i));
			else
				setnext(name.get(i), -1); // does not have next use info but still alive		}	}

	public boolean alive(Object o)
	{
		return name.contains(o);	}

	public int getnext(Object o)
	{
		if (name.contains(o))
		{			
			return nextuse.get(name.indexOf(o));
		}
		else return -1;
	}	
	public int getreg(Object o)
	{
		if (name.contains(o))
		{			
			return regloc.get(name.indexOf(o));
		}
		else return -1;
	}	
	public int getmem(Object o)
	{
		if (name.contains(o))
		{			
			return memloc.get(name.indexOf(o));
		}
		else return -1;
	}	
	public boolean setnext(Object o, int n)
	{
		if (name.contains(o))
		{
			nextuse.set(name.indexOf(o), n);
			return true;
		}
		else return false;
	}	
	public boolean setreg(Object o, int n)
	{
		if (name.contains(o))
		{
			regloc.set(name.indexOf(o), n);
			return true;
		}
		else return false;
	}
	public boolean setmem(Object o, int n)
	{
		if (name.contains(o))
		{
			memloc.set(name.indexOf(o), n);
			return true;
		}
		else return false;
	}

	@Override public String toString()
	{
		String r = "Symbol Table\n";
		for (int i = 0; i<name.size(); i++)
			r=r+""+name.get(i)+"\t"+nextuse.get(i)+"\t"+regloc.get(i)+"\t"+memloc.get(i)+"\n";
		return r;		
	}
}

public class JRR
{
  //public static HashMap<Object, Integer> symbol_table;
  public static ArrayList<Quad> quad_list;
  public static Stack<Object> semantic_stack;
  public static Stack<Integer> cdtn_stack, loop_stack;
  public static SymbolTable st; 
  
  public static void main(String args []) throws ParseException
  {
    JRR parser = new JRR(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      try
      {
        JRR.semantic_stack = new Stack<Object>();
        JRR.cdtn_stack = new Stack<Integer>();
        JRR.loop_stack = new Stack<Integer>();
        JRR.quad_list = new ArrayList<Quad>();
        //JRR.symbol_table = new HashMap<Object, Integer>();
        JRR.st = new SymbolTable();
        JRR.program();
        System.out.println("Successful Parsing.");
        System.out.println("\n------------------Stack------------------");
		System.out.println("Semantic Stack: "+semantic_stack);
		System.out.println("Cdtn Stack: "+cdtn_stack);
		System.out.println("Loop Stack: "+loop_stack);
		cleanJumps(quad_list);
		findLeaders(quad_list);
		genCode(quad_list);
		System.out.println("\n------------------Quads------------------");
		for (int i=0; i<quad_list.size();i++)
			System.out.println("Quad :"+i+"	"+quad_list.get(i));
        
      }
      catch(ParseException e){
        System.err.println("Fail Parsing");
        System.err.println(e);
        e.printStackTrace();
        break;
      }
      catch (Exception e)
      {
        System.out.println("Exception. ");
        e.printStackTrace();
        JRR.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Error.");
        System.out.println(e.getMessage());
        break;
      }
      
    }
  }
	public static void cleanJumps(ArrayList<Quad> list)
	{    
		for (int i = 0; i<list.size(); i++)    {
			if (list.get(i).op.startsWith("j")) 		{
				int crt = (int)list.get(i).result;
				while (list.get(crt).op.equals("jmp"))
					crt = (int)list.get(crt).result;
				list.get(i).result = crt;
			}
		}
	}

	public static void findLeaders(ArrayList<Quad> list)	{
		list.get(0).leader=true;		for (int i = 1; i<list.size()-1; i++)		{
			if (list.get(i).op.startsWith("j"))
			{				list.get((int)(list.get(i).result)).leader = true;
				if (!list.get(i).op.equals("jump"))
					list.get(i+1).leader = true;
			}		}
		// Last Quad: "exit" is not iterated over. always false unless set to be true
	}	

	public static void quad2code(Quad q)	{
		switch (q.op)
				{
					// ASSIGNMENT 
					case "mov":
						;
						if (st.getreg(q.arg1)==-1) //is not in a reg
						{
							int reg = st.rm.findreg();
							System.out.println("MOVE.L	"+q.arg1+"	"+reg);						}
						if ((!st.alive(q.arg1))&&st.getreg(q.arg1)!=-1)

						// MORE TO DO 
						break;
						
					// ARITHMETIC/LOGICAL
					case "+":
						;
						break;
					case "-":
						;
						break;
					case "*":
						;
						break;
					case "/":
						;
						break;
					case "%":
						;
						break;
					case "and":
						;
						break;
					case "or":
						;
						break;
					case "not":
						;
						break;
					case "neg":
						;
						break;
						
					// RELATIONAL
					case "LT":
						;
						break;
					case "GT":
						;
						break;
					case "tst":
						;
						break;
						
					// JUMPS 
					case "jmp":
						;
						break;
					case "jeqz":
						;
						break;
						
					case "ret":
						;
						break;
						
					default:
						System.out.println("Invalid op: "+q.op);
						break;
				}
	}

	public static void genCode(ArrayList<Quad> list)	{
		int crt = 0;		
		int next = crt+1;
		while (next<list.size())		{			while ((!list.get(next).leader)&&next<list.size()) next++;
			// crt, next are leaders of current and next basic blocks


			// PERFORM LIVE VARIABLE ANALYSIS //
			//symbol_table.clear();
			st.housekeeping();	
			for (int i = next-1; i >= crt; i--)			{
				// Symbol Table - > Quads
				/*
				if (list.get(i).arg1 instanceof Symbol) {
					if (symbol_table.containsKey(v))
						list.get(i).arg1 = new Symbol(v, symbol_table.get(v));
				}
				if (list.get(i).arg2 instanceof Symbol) {
					Object v = ((Symbol)list.get(i).arg2).name;
					if (symbol_table.containsKey(v))
						list.get(i).arg2 = new Symbol(v, symbol_table.get(v));
				}
				if (list.get(i).result instanceof Symbol) {
					Object v = ((Symbol)list.get(i).result).name;
					if (symbol_table.containsKey(v))
						list.get(i).result = new Symbol(v, symbol_table.get(v));
				}
				*/
				if (list.get(i).arg1 instanceof Symbol) {
					Object v = ((Symbol)list.get(i).arg1).name;
					if (st.alive(v)) list.get(i).arg1 = new Symbol(v, st.getnext(v));					
				}
				if (list.get(i).arg2 instanceof Symbol) {
					Object v = ((Symbol)list.get(i).arg2).name;
					if (st.alive(v)) list.get(i).arg2 = new Symbol(v, st.getnext(v));
				}
				if (list.get(i).result instanceof Symbol) {
					Object v = ((Symbol)list.get(i).result).name;
					if (st.alive(v)) list.get(i).result = new Symbol(v, st.getnext(v));
				}
				
	

				// Set new values for Symble Table				
				/*
				if (list.get(i).arg1 instanceof Symbol) { //only objects go to symbol table. ints and null don't 
					symbol_table.put(((Symbol)list.get(i).arg1).name,i);}
				if (list.get(i).arg2 instanceof Symbol) {
					symbol_table.put(((Symbol)list.get(i).arg2).name,i);}
				if (list.get(i).result instanceof Symbol) {
				  	symbol_table.put(((Symbol)list.get(i).result).name,-1);}
				 */
				if (list.get(i).arg1 instanceof Symbol)  //only objects go to symbol table. ints and null don't 
					st.add(((Symbol)list.get(i).arg1).name,i);
				if (list.get(i).arg2 instanceof Symbol)
					st.add(((Symbol)list.get(i).arg2).name,i);
				if (list.get(i).result instanceof Symbol)
					st.add(((Symbol)list.get(i).result).name,i);
				

							}
			
			// GENERATE CODE //
			for (int i = crt; i < next; i++)			{
				quad2code(list.get(i));
			}

			// GENERATE STORAGE INSTUCTIONS //







			// END OF THIS BLOCK //
			System.out.println(""+crt+"\t"+next);
			System.out.println(st);
			crt = next;
			next++; // when crt is exit, next is oob
			
		}

		
		
		for (int i = 0; i < list.size(); i++)		{		}	}
}

PARSER_END(JRR)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> //comments 
}

TOKEN : /* OPERATORS */
{
< LBRACE : "{" >
| < RBRACE : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LESSERTHAN : "<" >
| < GRATERTHAN : ">" >
}

TOKEN : // Reserved Words
{
  < BREAK:  "break" >
| < CONTINUE:  "continue" >
| < ELSE:  "else" >
| < IF:  "if" >
| < RETURN:  "return" >
| < WHILE:  "while" >
}

TOKEN : // ID and Digits
{
  < ID:  < LETTER >(< LETTER >|< DIGIT >)* >
| < #LETTER: ["a"-"z","A"-"Z","_"]>
| < INT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}


void program():{}
{
	< LBRACE > (statement())* < RBRACE > <EOF>	{
		quad_list.add(new Quad("exit",null,null,null));	}
	
}

void compound():{}
{
	< LBRACE > (statement())* < RBRACE > 
}

void statement():{Object a; int t1, t2; }
{
	//========== COMPOUND ===========
	compound() {}
	|
	
	//========== WHILE CLAUSE ===========
	< WHILE >	{
		loop_stack.push(quad_list.size());	}
	test()  {
		a = semantic_stack.pop();
		loop_stack.push(quad_list.size());
		quad_list.add(new Quad("jeqz",a,null,-1));	}
	statement() {
		t1 = loop_stack.pop(); // where loop body(conditional jump) starts
		t2 = loop_stack.pop(); // where loop testing block starts 
		quad_list.add(new Quad("jmp",null,null,t2));
		quad_list.get(t1).result = quad_list.size();
	}
	|

	//========== IF CLAUSE ===========
	< IF > test()	{
		t1 = quad_list.size(); //quad_list.size() MEANS NextQuad
		a = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",a,null,-1));
		cdtn_stack.push(t1); 	} statement() (LOOKAHEAD(2) < ELSE >   {
		t1 = quad_list.size(); 
		quad_list.add(new Quad("jmp",null,null,-1));
		t2 = cdtn_stack.pop();
		quad_list.get(t2).result = quad_list.size();
		cdtn_stack.push(t1);     	} statement())? {
		t1 = cdtn_stack.pop();
		quad_list.get(t1).result = quad_list.size();
	}
	|

	//========== EXPRESSION ===========
	expression() ";" {
		semantic_stack.pop();
	}
	|

	//========== BREAK CLAUSE ===========
	< BREAK >";" { //TODO implement BREAK
		t1 = loop_stack.pop();
		t2 = quad_list.size();
		quad_list.add(new Quad("jmp",null,null,t1));
		quad_list.get(t1).result = t2;
		loop_stack.push(t2);
	}
	|

	//========== RETURN CLAUSE ===========
	< RETURN > expression()";" {
		a = semantic_stack.pop();
		quad_list.add(new Quad("ret",null,null,a));
	}
	|
	
	//========== CONTINUE CLAUSE ===========
	< CONTINUE > ";" {
		t2 = loop_stack.pop();
		t1 = loop_stack.peek(); // the starting point of test is one into the top of stack
		loop_stack.push(t2);
		quad_list.add(new Quad("jmp",null,null,t1));
	}
	|

	//========== SEMICOLON ===========
	";" {
	}
}
void test():{}
{
	< LPAREN > expression() < RPAREN > 
}

void expression():{} 
{
	LOOKAHEAD(2)  
	{ Token id; }
	id=< ID >	{
		semantic_stack.push(id.image);
	}
	"=" expression() {
		Object a = semantic_stack.pop(); //the latter
		Object b = semantic_stack.pop(); //the first (destination)
		quad_list.add(new Quad("mov",a,null,b));
		semantic_stack.push(b);
	}
	|
	condition() 
}

void condition():{Object a, b, c; int t1, t2;}
{
	disjunction() ("?"	{
		t1 = quad_list.size();
		a = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",a,null,-1));
		cdtn_stack.push(t1);
		Object dest = new Object(); // the place to be assigned
	}
	expression() ":"	{
		b = semantic_stack.pop();
		quad_list.add(new Quad("mov",b,null,dest));
		t1 = quad_list.size(); 
		quad_list.add(new Quad("jmp",null,null,-1));
		t2 = cdtn_stack.pop();
		quad_list.get(t2).result = quad_list.size();
		cdtn_stack.push(t1);
	}
	condition() 	{
		c = semantic_stack.pop();
		quad_list.add(new Quad("mov",c,null,dest));
		t1 = cdtn_stack.pop();
		quad_list.get(t1).result = quad_list.size();  
		semantic_stack.push(dest);
	}
	)?
}

void disjunction():{}
{
	conjunction() ("|" conjunction()	{
		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("or",c,b,a));
		semantic_stack.push(a);
	}
	)*  
}

void conjunction():{}
{
	comparison() ("&" comparison()	{
		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("and",c,b,a));
		semantic_stack.push(a);	}
	)*
}

void comparison():{}
{
	relation() ("==" relation() {
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("tst",c,b,a));
		semantic_stack.push(a);
	}
	)? 
}

void relation():{String op;}
{
	sum() (op=relop() sum()	{
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)?
}

void sum():{String op;}
{
	term()( op=addop() term()	{
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);	}
	)*
}

void term():{String op;}
{
	factor() (op=mulop() factor() {		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)*
}

void factor():{}
{
	primary()
	|
	{ String op;}
	op=unaryop() primary() {		Object a = new Object();
		Object b = semantic_stack.pop();
		quad_list.add(new Quad(op,b,null,a));
		semantic_stack.push(a);
	}
}

void primary():{}
{  
	{ Token id; }
	id = < ID >  {
//		Symbol s = new Symbol(id.image);
//		if (!symbol_table.contains(s))
//			symbol_table.add(s);
	    semantic_stack.push(id.image);
    }
    |
    {Token i;}
    i = < INT >	{		semantic_stack.push(Integer.parseInt(i.image));
	}
	|
	< LPAREN > expression() < RPAREN > 
}

String relop():{}
{
	< LESSERTHAN >{return "LT";}
	|
	< GRATERTHAN >{return "GT";}
}

String mulop():{}
{
	"*"  {return "*";}
	|
	"/"  {return "/";}
	|
	"%"  {return "%";}
}

String addop():{}
{
	"-"{return "-";}
	|
	"+"{return "+";}
}

String unaryop():{}
{
	"-"{return "neg";}
	|
	"!"{return "not";}
}

// E: E+T|T  becomes E: T(+T)*
