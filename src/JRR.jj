/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(JRR)
import java.util.*;

class Symbol
{
	public Object name;
	public int nextuse;
	public Symbol(Object o)
	{	
		name = o;
		//nextuse = -1;
		if (!(o instanceof String)) // temp
			nextuse=-1;			
		else
			nextuse=0;	
			
	}
	public Symbol(Object o, int n)
	{	
		name = o;
		nextuse = n;
	}

	@Override public boolean equals(Object o)
	{
		if (o instanceof Symbol)
			return (((Symbol)o).name.equals(name));
		else return false;
	}
	@Override public String toString()
	{
		return "(["+name+"]["+nextuse+"])";		
	}
}

class Quad{	String op;
	Object arg1, arg2, result;
	boolean leader;
	public Quad(String o, Object a1, Object a2, Object re)	{
	  op = o;

	  //System.out.println(a1 + "" + (arg1 instanceof Integer));
	  
	  if ((a1 instanceof Integer)||a1==null)	arg1 = a1;
	  else arg1 = new Symbol(a1);
	  
	  if ((a2 instanceof Integer)||a2==null)	arg2 = a2;
	  else arg2 = new Symbol(a2);
	  
	  if ((re instanceof Integer)||re==null)	result = re;
	  else result = new Symbol(re);
	  
	  leader = false;
	  //System.out.println(this);
	}
	
	@Override public String toString()
	{
		String s = ">";
		if (op != null) s = s+op.toString()+"<	>";
	  	else s = s+"NULL"+"<	>";
  		if (arg1 != null) s = s+arg1.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (arg2 != null) s = s+arg2.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		if (result != null) s = s+result.toString()+"<	>";
		else s = s+"NULL"+"<	>";
		s = s+leader+"<";
		return s;
	}
}

class SymbolTable
{
	class RegManager
	{
		ArrayList<ArrayList<Object>> regs;
		public RegManager(int cap)
		{
			regs = new ArrayList<ArrayList<Object>>();
			for (int i = 0; i < cap; i++) regs.add(new ArrayList<Object>());
		}
	
		boolean regavail (ArrayList<Object> l)
		{
			for (Object o: l)
				if (alive(o)) return false;
			return true;
		}
	
		public int findreg ()
		{
			for (int i = 0; i < regs.size(); i++)
			{
				if (regavail(regs.get(i)))
					return i;
			}
			// fail to find a empty reg
			int r = 0;
			for (int i = 0; i < regs.get(r).size(); i++)
			{
				m.store(regs.get(r).get(i));				
			}
			regs.set(r, new ArrayList<Object>());		
			return r;
		}
	}

	class Memory
	{		ArrayList<Boolean> m;
		int base, step;
		public Memory(int cap)		{
			m = new ArrayList<Boolean>(cap);
			for (int i = 0; i < 256; i++) m.add(false);
			base = 0; //eax: 32bits, 4bytes
			step = 1;		}
		void store(Object o)		{
			int i = m.indexOf(false);
			m.set(i,true);
			setmem(o,i);
			System.out.println("MOVL\t%R"+getreg(o)+",\t0x"+Integer.toHexString(i)+"\n");		}
	}
	
	ArrayList<Object> name;
	ArrayList<Integer> nextuse;
	ArrayList<Integer> regloc;
	ArrayList<Integer> memloc;
	RegManager rm;
	Memory m;

	public SymbolTable ()	{
		name = new ArrayList<Object>();
		nextuse = new ArrayList<Integer>();
		regloc = new ArrayList<Integer>();
		memloc = new ArrayList<Integer>();
		rm = new RegManager(8);
		m = new Memory(256);	}

	public boolean add(Object o)
	{
		if (!name.contains(o))
		{
			name.add(o);
			if (!(o instanceof String)) // temp
				nextuse.add(-1);			
			else
				nextuse.add(0);	
			regloc.add(-1);
			memloc.add(-1);
			return true;
		}
		else return false;
	}
	
	public void add(Object o, int n)
	{
		if (!name.contains(o))
		{
			name.add(o);
			nextuse.add(n);
			regloc.add(-1);
			memloc.add(-1);
		}
		else setnext(o,n);
	}
	
	public boolean del(Object o)
	{
		if (name.contains(o))
		{
			int i = name.indexOf(o);
			name.remove(i);
			nextuse.remove(i);
			regloc.remove(i);
			memloc.remove(i);
			return true;
		}
		else return false;
	}

	public void housekeeping()	{
		for (int i = 0; i<name.size(); i++)
		{
			if (!(name.get(i) instanceof String))
				del(name.get(i));
			else
				setnext(name.get(i), 0); // does not have next use info but still alive		}	}

	public boolean alive(Object o)
	{
		return getnext(o) >= 0;	}

	public int getnext(Object o)
	{
		if (name.contains(o))
		{			
			return nextuse.get(name.indexOf(o));
		}
		else return -1;
	}	
	public int getreg(Object o)
	{
		if (name.contains(o))
		{			
			return regloc.get(name.indexOf(o));
		}
		else return -1;
	}	
	public int getmem(Object o)
	{
		if (name.contains(o))
		{			
			return memloc.get(name.indexOf(o));
		}
		else return -1;
	}	
	public boolean setnext(Object o, int n)
	{
		if (name.contains(o))
		{
			nextuse.set(name.indexOf(o), n);
			return true;
		}
		else return false;
	}	
	public boolean setreg(Object o, int n)
	{
		if (name.contains(o))
		{
			regloc.set(name.indexOf(o), n);
			return true;
		}
		else return false;
	}
	public boolean setmem(Object o, int n)
	{
		if (name.contains(o))
		{
			memloc.set(name.indexOf(o), n);
			return true;
		}
		else return false;
	}

	@Override public String toString()
	{
		String r = "Symbol Table\n";
		for (int i = 0; i<name.size(); i++)
			r=r+""+name.get(i)+"\t"+nextuse.get(i)+"\t"+regloc.get(i)+"\t"+memloc.get(i)+"\n";
		return r;		
	}
}

public class JRR
{
  //public static HashMap<Object, Integer> symbol_table;
  public static ArrayList<Quad> quad_list;
  public static Stack<Object> semantic_stack;
  public static Stack<Integer> cdtn_stack, loop_stack;
  public static SymbolTable st;
  public static String ins; 
  
  public static void main(String args []) throws ParseException
  {
    JRR parser = new JRR(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      try
      {
        JRR.semantic_stack = new Stack<Object>();
        JRR.cdtn_stack = new Stack<Integer>();
        JRR.loop_stack = new Stack<Integer>();
        JRR.quad_list = new ArrayList<Quad>();
        //JRR.symbol_table = new HashMap<Object, Integer>();
        JRR.st = new SymbolTable();
        JRR.program();
        JRR.ins = "";
        System.out.println("Successful Parsing.");
        System.out.println("\n------------------Stack------------------");
		System.out.println("Semantic Stack: "+semantic_stack);
		System.out.println("Cdtn Stack: "+cdtn_stack);
		System.out.println("Loop Stack: "+loop_stack);
		cleanJumps(quad_list);
		findLeaders(quad_list);		
		System.out.println("\n------------------Quads------------------");
		for (int i=0; i<quad_list.size();i++)
			System.out.println("Quad :"+i+"	"+quad_list.get(i));

		genCode(quad_list);
        
      }
      catch(ParseException e){
        System.err.println("Fail Parsing");
        System.err.println(e);
        e.printStackTrace();
        break;
      }
      catch (Exception e)
      {
        System.out.println("Exception. ");
        e.printStackTrace();
        JRR.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Error.");
        System.out.println(e.getMessage());
        break;
      }
      
    }
  }
	public static void cleanJumps(ArrayList<Quad> list)
	{    
		for (int i = 0; i<list.size(); i++)    {
			if (list.get(i).op.startsWith("j")) 		{
				int crt = (int)list.get(i).result;
				while (list.get(crt).op.equals("jmp"))
					crt = (int)list.get(crt).result;
				list.get(i).result = crt;
			}
		}
	}

	public static void findLeaders(ArrayList<Quad> list)	{
		list.get(0).leader=true;		for (int i = 1; i<list.size()-1; i++)		{
			if (list.get(i).op.startsWith("j"))
			{				list.get((int)(list.get(i).result)).leader = true;
				if (!list.get(i).op.equals("jump"))
					list.get(i+1).leader = true;
			}		}
		// Last Quad: "exit" is not iterated over. always false unless set to be true
	}	

	public static void quad2code(Quad q)	{
		int reg;
		Object n=null;
		String opr = "";
		switch (q.op)
				{		
					// ASSIGNMENT
					case "mov":
						
						// source is an integer
						if (q.arg1 instanceof Integer)  						{
							reg = st.rm.findreg();
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");						}
						else 						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, but not in reg. must be in storage
							if (st.getreg(n)==-1)							{
								reg = st.rm.findreg();
								st.setreg(n, reg);
								System.out.println("MOVL\t$0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");							}
							// source is already in a reg			
							else reg = st.getreg(n);


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}													}

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
						
					// ARITHMETIC/LOGICAL
					case "+":
						reg = st.rm.findreg();
						opr = "ADDL";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}						}

						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t"+"%R"+reg+",\t%R"+reg+"\n");						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+",\t%R"+reg+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
								}							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}						}

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
						
					case "-":
						reg = st.rm.findreg();
						opr = "SUBL";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t"+"%R"+reg+",\t%R"+reg+"\n");
						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+",\t%R"+reg+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
								}
							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
					case "*":
						opr = "IMUL";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%EAX\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%EAX\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%EAX\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(st.getreg(n)).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t%EAX\n");
						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+"\n");
								}
							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(st.getreg(n)).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						n = ((Symbol)(q.result)).name;
						reg = st.rm.findreg();
						System.out.println("MOVL\t"+"%EAX"+",\t%R"+reg+"\n");
						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
					case "/":
						opr = "IDIV";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%EAX\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%EAX\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%EAX\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(st.getreg(n)).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						System.out.println("CDQ\n");
						
						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t%EAX\n");
						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+"\n");
								}
							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(st.getreg(n)).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						n = ((Symbol)(q.result)).name;
						reg = st.rm.findreg();
						System.out.println("MOVL\t"+"%EAX"+",\t%R"+reg+"\n");
						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
					case "%":
						opr = "IDIV";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%EAX\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%EAX\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%EAX\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(st.getreg(n)).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						System.out.println("CDQ\n");
						

						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t%EAX\n");
						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+"\n");
								}
							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(st.getreg(n)).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						n = ((Symbol)(q.result)).name;
						reg = st.rm.findreg();
						System.out.println("MOVL\t"+"%EDX"+",\t%R"+reg+"\n");
						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;						
					case "and":
						reg = st.rm.findreg();
						opr = "ANDL";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t"+"%R"+reg+",\t%R"+reg+"\n");
						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+",\t%R"+reg+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
								}
							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
					case "or":
						reg = st.rm.findreg();
						opr = "ORL";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						if (q.arg1.equals(q.arg2))
						{
							System.out.println(opr+"\t"+"%R"+reg+",\t%R"+reg+"\n");
						}
						else
						{
							if (q.arg2 instanceof Integer)
								System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+",\t%R"+reg+"\n");
							else
							{
								// arg2 is a Symbol 
								n = ((Symbol)(q.arg2)).name;
								// arg2 is not in a reg
								if (st.getreg(n) == -1) 
								{
									System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
								}
								// source is a Symbol, in a reg	
								else
								{
									System.out.println(opr+"\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
								}
							}


							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
					case "not":
						reg = st.rm.findreg();
						opr = "NOTL";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						System.out.println(opr+"\t%R"+reg+"\n");

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
					case "neg":
						reg = st.rm.findreg();
						opr = "NEG";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						System.out.println(opr+"\t%R"+reg+"\n");

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
						
					// RELATIONAL
					case "GT":
						reg = st.rm.findreg();
						opr = "CMP";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						if (q.arg2 instanceof Integer)
							System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+",\t%R"+reg+"\n");
						else
						{
							// arg2 is a Symbol 
							n = ((Symbol)(q.arg2)).name;
							// arg2 is not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println(opr+"\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						// CMP A, B
						// JG jumps if b is greater
						
						System.out.println("JG\t"+".+"+7+"\n"); // Jump to P1 					// 7F XX
						System.out.println("MOVL\t$0x"+0+",\t%R"+reg+"\n");						// MV 00 RR
						System.out.println("JMP\t"+".+"+5+"\n"); //Jump to P2					// JP XX
						// P1
						System.out.println("MOVL\t$0x"+1+",\t%R"+reg+"\n");						// MV 00 RR
						// P2

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
						
					case "LT":
						reg = st.rm.findreg();
						opr = "CMP";
						
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						if (q.arg2 instanceof Integer)
							System.out.println(opr+"\t$0x"+Integer.toHexString((int)q.arg2)+",\t%R"+reg+"\n");
						else
						{
							// arg2 is a Symbol 
							n = ((Symbol)(q.arg2)).name;
							// arg2 is not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println(opr+"\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println(opr+"\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg2 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						// CMP A, B
						// JG jumps if b is greater
						
						System.out.println("JL\t"+".+"+7+"\n"); // Jump to P1 					// 7F XX
						System.out.println("MOVL\t$0x"+0+",\t%R"+reg+"\n");						// MV 00 RR
						System.out.println("JMP\t"+".+"+5+"\n"); //Jump to P2					// JP XX
						// P1
						System.out.println("MOVL\t$0x"+1+",\t%R"+reg+"\n");						// MV 00 RR
						// P2

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
						
					case "tst":
						reg = st.rm.findreg();

						// Simply move changes the flags
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						System.out.println("JZ\t"+".+"+7+"\n"); // Jump to P1 					// 7F XX
						System.out.println("MOVL\t$0x"+0+",\t%R"+reg+"\n");						// MV 00 RR
						System.out.println("JMP\t"+".+"+5+"\n"); //Jump to P2					// JP XX
						// P1
						System.out.println("MOVL\t$0x"+1+",\t%R"+reg+"\n");						// MV 00 RR
						// P2

						n = ((Symbol)(q.result)).name;

						st.setreg(n,reg); // update ST.Locations for A to indicate it is in REG and nowhere else
						st.rm.regs.get(reg).add(n); // update Reg Table to indicate A is in it
						st.setmem(n,-1);
						break;
												
					// JUMPS 
					case "jmp":
						for (Object o: st.name)
						{
							if (st.getmem(o) >-1) st.m.store(o);
						}
						System.out.println("JMP\t"+0+"\n");
						int i = (int)q.result;
						break;
					case "jeqz":
						reg = st.rm.findreg();
						//opr = "CMP";


						for (Object o: st.name)						{
							if (st.getmem(o) >-1) st.m.store(o);						}						

						// Simply move changes the flags
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%R"+reg+"\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%R"+reg+"\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%R"+reg+"\n");
							}

							
							if ( (!st.alive(n))	&&	(st.getreg(n) >-1) ) // if arg1 is dead, 
							{
								st.rm.regs.get(reg).remove(n);
								st.setreg(n,-1);
								st.setmem(n,-1);							
							}
						}

						System.out.println("JZ\t"+".+"+7+"\n"); // Jump to P1 					// 7F XX
						int j = (int)q.result;
						break;
						
					case "ret":
						if (q.arg1 instanceof Integer)
							System.out.println("MOVL\t$0x"+Integer.toHexString((int)q.arg1)+",\t%EAX\n");
						else
						{
							n = ((Symbol)(q.arg1)).name;
							// source is a Symbol, not in a reg
							if (st.getreg(n) == -1) 
							{
								System.out.println("MOVL\t0x"+Integer.toHexString(st.getmem(n))+",\t%EAX\n");
							}
							// source is a Symbol, in a reg	
							else
							{
								System.out.println("MOVL\t"+"%R"+st.getreg(n)+",\t%EAX\n");
							}

							
							for (Object o: st.name)
							{
								if (st.getmem(o) >-1) st.m.store(o);
							}
						}
						break;
						
					default:
						System.out.println("Invalid op: "+q.op);
						break;
				}
	}

	public static void genCode(ArrayList<Quad> list)	{
		int crt = 0;		
		int next = crt+1;
		while (next<list.size())		{			while ((!list.get(next).leader)&&next<list.size()) next++;
			// crt, next are leaders of current and next basic blocks


			// PERFORM LIVE VARIABLE ANALYSIS //
			//symbol_table.clear();
			for (int i = next-1; i >= crt; i--)			{
				// Symbol Table - > Quads
				/*
				if (list.get(i).arg1 instanceof Symbol) {
					if (symbol_table.containsKey(v))
						list.get(i).arg1 = new Symbol(v, symbol_table.get(v));
				}
				if (list.get(i).arg2 instanceof Symbol) {
					Object v = ((Symbol)list.get(i).arg2).name;
					if (symbol_table.containsKey(v))
						list.get(i).arg2 = new Symbol(v, symbol_table.get(v));
				}
				if (list.get(i).result instanceof Symbol) {
					Object v = ((Symbol)list.get(i).result).name;
					if (symbol_table.containsKey(v))
						list.get(i).result = new Symbol(v, symbol_table.get(v));
				}
				*/
				if (list.get(i).arg1 instanceof Symbol) {
					Object v = ((Symbol)list.get(i).arg1).name;
					if (st.alive(v)) list.get(i).arg1 = new Symbol(v, st.getnext(v));					
				}
				if (list.get(i).arg2 instanceof Symbol) {
					Object v = ((Symbol)list.get(i).arg2).name;
					if (st.alive(v)) list.get(i).arg2 = new Symbol(v, st.getnext(v));
				}
				if (list.get(i).result instanceof Symbol) {
					Object v = ((Symbol)list.get(i).result).name;
					if (st.alive(v)) list.get(i).result = new Symbol(v, st.getnext(v));
				}
				
	

				// Set new values for Symble Table				
				/*
				if (list.get(i).arg1 instanceof Symbol) { //only objects go to symbol table. ints and null don't 
					symbol_table.put(((Symbol)list.get(i).arg1).name,i);}
				if (list.get(i).arg2 instanceof Symbol) {
					symbol_table.put(((Symbol)list.get(i).arg2).name,i);}
				if (list.get(i).result instanceof Symbol) {
				  	symbol_table.put(((Symbol)list.get(i).result).name,-1);}
				 */
				if (list.get(i).arg1 instanceof Symbol)  //only objects go to symbol table. ints and null don't 
					st.add(((Symbol)list.get(i).arg1).name,i);
				if (list.get(i).arg2 instanceof Symbol)
					st.add(((Symbol)list.get(i).arg2).name,i);
				if (list.get(i).result instanceof Symbol)
					st.add(((Symbol)list.get(i).result).name,i);
				

							}
			
			// GENERATE CODE //
			for (int i = crt; i < next; i++)			{
				quad2code(list.get(i));
			}

			// GENERATE STORAGE INSTUCTIONS //
			







			// END OF THIS BLOCK //
			System.out.println(""+crt+"\t"+next);
			st.housekeeping();	
			
			//System.out.println(st);
			crt = next;
			next++; // when crt is exit, next is oob
			
		}

		
		
		for (int i = 0; i < list.size(); i++)		{		}	}
}

PARSER_END(JRR)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> //comments 
}

TOKEN : /* OPERATORS */
{
< LBRACE : "{" >
| < RBRACE : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LESSERTHAN : "<" >
| < GRATERTHAN : ">" >
}

TOKEN : // Reserved Words
{
  < BREAK:  "break" >
| < CONTINUE:  "continue" >
| < ELSE:  "else" >
| < IF:  "if" >
| < RETURN:  "return" >
| < WHILE:  "while" >
}

TOKEN : // ID and Digits
{
  < ID:  < LETTER >(< LETTER >|< DIGIT >)* >
| < #LETTER: ["a"-"z","A"-"Z","_"]>
| < INT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}


void program():{}
{
	< LBRACE > (statement())* < RBRACE > <EOF>	{
		quad_list.add(new Quad("exit",null,null,null));	}
	
}

void compound():{}
{
	< LBRACE > (statement())* < RBRACE > 
}

void statement():{Object a; int t1, t2; }
{
	//========== COMPOUND ===========
	compound() {}
	|
	
	//========== WHILE CLAUSE ===========
	< WHILE >	{
		loop_stack.push(quad_list.size());	}
	test()  {
		a = semantic_stack.pop();
		loop_stack.push(quad_list.size());
		quad_list.add(new Quad("jeqz",a,null,-1));	}
	statement() {
		t1 = loop_stack.pop(); // where loop body(conditional jump) starts
		t2 = loop_stack.pop(); // where loop testing block starts 
		quad_list.add(new Quad("jmp",null,null,t2));
		quad_list.get(t1).result = quad_list.size();
	}
	|

	//========== IF CLAUSE ===========
	< IF > test()	{
		t1 = quad_list.size(); //quad_list.size() MEANS NextQuad
		a = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",a,null,-1));
		cdtn_stack.push(t1); 	} statement() (LOOKAHEAD(2) < ELSE >   {
		t1 = quad_list.size(); 
		quad_list.add(new Quad("jmp",null,null,-1));
		t2 = cdtn_stack.pop();
		quad_list.get(t2).result = quad_list.size();
		cdtn_stack.push(t1);     	} statement())? {
		t1 = cdtn_stack.pop();
		quad_list.get(t1).result = quad_list.size();
	}
	|

	//========== EXPRESSION ===========
	expression() ";" {
		semantic_stack.pop();
	}
	|

	//========== BREAK CLAUSE ===========
	< BREAK >";" { //TODO implement BREAK
		t1 = loop_stack.pop();
		t2 = quad_list.size();
		quad_list.add(new Quad("jmp",null,null,t1));
		quad_list.get(t1).result = t2;
		loop_stack.push(t2);
	}
	|

	//========== RETURN CLAUSE ===========
	< RETURN > expression()";" {
		a = semantic_stack.pop();
		quad_list.add(new Quad("ret",a,null,null));
	}
	|
	
	//========== CONTINUE CLAUSE ===========
	< CONTINUE > ";" {
		t2 = loop_stack.pop();
		t1 = loop_stack.peek(); // the starting point of test is one into the top of stack
		loop_stack.push(t2);
		quad_list.add(new Quad("jmp",null,null,t1));
	}
	|

	//========== SEMICOLON ===========
	";" {
	}
}
void test():{}
{
	< LPAREN > expression() < RPAREN > 
}

void expression():{} 
{
	LOOKAHEAD(2)  
	{ Token id; }
	id=< ID >	{
		semantic_stack.push(id.image);
	}
	"=" expression() {
		Object a = semantic_stack.pop(); //the latter
		Object b = semantic_stack.pop(); //the first (destination)
		quad_list.add(new Quad("mov",a,null,b));
		semantic_stack.push(b);
	}
	|
	condition() 
}

void condition():{Object a, b, c; int t1, t2;}
{
	disjunction() ("?"	{
		t1 = quad_list.size();
		a = semantic_stack.pop();
		quad_list.add(new Quad("jeqz",a,null,-1));
		cdtn_stack.push(t1);
		Object dest = new Object(); // the place to be assigned
	}
	expression() ":"	{
		b = semantic_stack.pop();
		quad_list.add(new Quad("mov",b,null,dest));
		t1 = quad_list.size(); 
		quad_list.add(new Quad("jmp",null,null,-1));
		t2 = cdtn_stack.pop();
		quad_list.get(t2).result = quad_list.size();
		cdtn_stack.push(t1);
	}
	condition() 	{
		c = semantic_stack.pop();
		quad_list.add(new Quad("mov",c,null,dest));
		t1 = cdtn_stack.pop();
		quad_list.get(t1).result = quad_list.size();  
		semantic_stack.push(dest);
	}
	)?
}

void disjunction():{}
{
	conjunction() ("|" conjunction()	{
		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("or",c,b,a));
		semantic_stack.push(a);
	}
	)*  
}

void conjunction():{}
{
	comparison() ("&" comparison()	{
		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("and",c,b,a));
		semantic_stack.push(a);	}
	)*
}

void comparison():{}
{
	relation() ("==" relation() {
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad("tst",c,b,a));
		semantic_stack.push(a);
	}
	)? 
}

void relation():{String op;}
{
	sum() (op=relop() sum()	{
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)?
}

void sum():{String op;}
{
	term()( op=addop() term()	{
  		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);	}
	)*
}

void term():{String op;}
{
	factor() (op=mulop() factor() {		Object a = new Object();
		Object b = semantic_stack.pop();
		Object c = semantic_stack.pop();
		quad_list.add(new Quad(op,c,b,a));
		semantic_stack.push(a);
	}
	)*
}

void factor():{}
{
	primary()
	|
	{ String op;}
	op=unaryop() primary() {		Object a = new Object();
		Object b = semantic_stack.pop();
		quad_list.add(new Quad(op,b,null,a));
		semantic_stack.push(a);
	}
}

void primary():{}
{  
	{ Token id; }
	id = < ID >  {
//		Symbol s = new Symbol(id.image);
//		if (!symbol_table.contains(s))
//			symbol_table.add(s);
	    semantic_stack.push(id.image);
    }
    |
    {Token i;}
    i = < INT >	{		semantic_stack.push(Integer.parseInt(i.image));
	}
	|
	< LPAREN > expression() < RPAREN > 
}

String relop():{}
{
	< LESSERTHAN >{return "LT";}
	|
	< GRATERTHAN >{return "GT";}
}

String mulop():{}
{
	"*"  {return "*";}
	|
	"/"  {return "/";}
	|
	"%"  {return "%";}
}

String addop():{}
{
	"-"{return "-";}
	|
	"+"{return "+";}
}

String unaryop():{}
{
	"-"{return "neg";}
	|
	"!"{return "not";}
}

// E: E+T|T  becomes E: T(+T)*
